from pyspark.sql.functions import col, lit, when, concat_ws
import numpy as np
import traceback

def get_hot_sectors_sparkdf(vendor, startdt, enddt, coreDB, avgLevel, enodebs=None, markets=[], spark=None):
    """
    Unified function to process PRB data for Ericsson, Nokia, and Samsung with vendor-specific conditions.
    """
    prb_data = None  # Initialize dataset

    vendor_map = {
        "Ericsson": {
            "prefix": "eric_avg_iot_prb",
            "get_prb_function": get_erc_prbdata_hrly,
            "invalid_condition": lambda col_val: when((col(col_val) < -30), None),
        },
        "Nokia": {
            "prefix": "nok_avg_iot_prb",
            "get_prb_function": get_nokia_prbdata,
            "invalid_condition": lambda col_val: when((col(col_val) < -25) | (col(col_val) > 50), None),
        },
        "Samsung": {
            "prefix": "sea_avg_iot_prb",
            "get_prb_function": get_samsung_prbdata,
            "invalid_condition": lambda col_val: when((col(col_val) < -20) | (col(col_val) > 45), None),
        }
    }

    if vendor not in vendor_map:
        raise ValueError("Invalid vendor. Choose from 'Ericsson', 'Nokia', or 'Samsung'.")

    prefix = vendor_map[vendor]["prefix"]
    get_prb_function = vendor_map[vendor]["get_prb_function"]
    invalid_value_handler = vendor_map[vendor]["invalid_condition"]

    try:
        print(f"Fetching PRB data for {vendor}...")
        prb_data = get_prb_function(startdt, enddt, coreDB, enodebs, spark, markets)
        prb_data = prb_data.drop_duplicates()

        prb_cols = [(idx, int(prb_col.split(prefix)[1])) for idx, prb_col in enumerate(prb_data.columns) if prefix in prb_col]
        prb_cols = np.array(prb_cols)
        sorted_prb_cols = prb_cols[np.argsort(prb_cols[:, 1]), 0]
        sorted_col_names = list(np.array(prb_data.columns)[sorted_prb_cols])

        print("Standardizing columns...")
        prb_data = prb_data.select([
            col(c).cast('float').alias('{}{}_dbm'.format(prefix, int(c.split(prefix)[1]) + (1 if vendor in ["Nokia", "Samsung"] else 0)))
            if c in sorted_col_names else col(c)
            for c in prb_data.columns
        ])

        print(f"Applying vendor-specific value formatting for {vendor}...")
        prb_data = prb_data.select([
            invalid_value_handler(c).otherwise(col(c)).alias(c)
            if c in sorted_col_names else col(c)
            for c in prb_data.columns
        ])

        prb_data = prb_data.withColumnRenamed('enodeb', 'ENODEB') \
                           .withColumnRenamed('eutrancell', 'EUTRANCELL') \
                           .withColumnRenamed('carrier', 'CARRIER')

        if vendor != "Ericsson":
            prb_data = prb_data.withColumn('rfbranchrx', lit(1))

        prb_data = prb_data.withColumn('SECTORCARRIERREF', concat_ws('_', prb_data.EUTRANCELL, prb_data.CARRIER))

        selected_columns = sorted_col_names + ['ENODEB', 'SECTORCARRIERREF', 'rfbranchrx']
        prb_data_avg = prb_data.select(selected_columns)

        print("Applying aggregation functions...")
        avg_prb = prb_data_avg.groupBy(['ENODEB', 'SECTORCARRIERREF', 'rfbranchrx']).apply(branch_average)
        std_prb = prb_data_avg.groupBy(['ENODEB', 'SECTORCARRIERREF', 'rfbranchrx']).apply(branch_stdev_all_dbm)
        all_prb_stats = avg_prb.join(std_prb, on=['ENODEB', 'SECTORCARRIERREF', 'rfbranchrx'])

        prb_data_avg = prb_data_avg.join(all_prb_stats, on=['ENODEB', 'SECTORCARRIERREF', 'rfbranchrx'], how='left_anti')
        avg_prb_all = prb_data_avg.drop('rfbranchrx').groupBy(['ENODEB', 'SECTORCARRIERREF']).apply(seccar_average)

        top_interferers = avg_prb_all.filter(col("WEIGHTEDAVGRADIOINTERFERENCE") >= avgLevel)
        print(f"Found {top_interferers.count()} sectors with U1 average interference higher than {avgLevel}")

        print("Final join...")
        prb_data = prb_data.select(selected_columns).join(top_interferers, on=['ENODEB', 'SECTORCARRIERREF'])

        print("Unpersisting...")

    except Exception as e:
        print(f"-ERROR- Could not extract {vendor} PRB data: {e}")
        traceback.print_exc()

    return prb_data, all_prb_stats
